<html>
	<head>
		<script src="../../vendor/vr.js"></script>
		<script src="../../vendor/three.min.js"></script>
		<script src="../../vendor/vr/effects/OculusRiftEffect.js"></script>
		<script src="../../vendor/vr/controls/OculusRiftControls.js"></script>

		<style>
			canvas {
				/*-webkit-filter: contrast(3) hue-rotate(180deg) saturate(10);*/
			}
		</style>
	</head>
	<body>
		<script>
			CanvasFilter = {};
			CanvasFilter.filters = {};

			CanvasFilter.tmpCanvas = document.createElement('canvas');
			CanvasFilter.tmpCtx = CanvasFilter.tmpCanvas.getContext('2d');

			CanvasFilter.getPixels = function(canvas, context) {
				context = context ? context : canvas.getContext('2d');
				return context.getImageData(0, 0, canvas.width, canvas.height);
			};

			CanvasFilter.applyFilter = function(canvas, context, filter) {
				var args = [this.getPixels(canvas, context)];
				for (var i=3; i<arguments.length; i++) {
					args.push(arguments[i]);
				}
				return filter.apply(null, args);
			};

			CanvasFilter.filterPixels = function(pixels, filter) {
				var args = [pixels];
				for (var i=2; i<arguments.length; i++) {
					args.push(arguments[i]);
				}
				return filter.apply(null, args);
			};

			CanvasFilter.createImageData = function(width, height) {
				return this.tmpCtx.createImageData(width, height);
			}

			CanvasFilter.filters.grayscale = function(pixels, args) {
				var d,r,g,b,v;

				d = pixels.data;
				for (var i=0; i<d.length; i+=4) {
					r = d[i];
					g = d[i+1];
					b = d[i+2];
					v = 0.2126*r + 0.7152*g + 0.0722*b;
					d[i] = d[i+1] = d[i+2] = v;
				}

				return pixels;
			};

			CanvasFilter.filters.sepia = function(pixels, args) {
				var d, ir, ig, ib, or, og, ob;

				d = pixels.data;
				for (var i=0; i<d.length; i+=4) {
					ir = d[i]; ig = d[i+1]; ib = d[i+2];

					or = Math.min(.393*ir + .769*ig + .189*ib, 255);
					og = Math.min(.349*ir + .686*ig + .168*ib, 255);
					ob = Math.min(.272*ir + .534*ig + .131*ib, 255);

					d[i] = or; d[i+1] = og; d[i+2] = ob;
				}

				return pixels;
			};

			CanvasFilter.filters.spycam = function(pixels, width, height) {
				var d, ir, ig, ib, or, og, ob;

				d = pixels.data;
				for (var i=0; i<d.length; i+=4) {
					ir = d[i]; ig = d[i+1]; ib = d[i+2];

					// apply blue style sepia
					or = .272*ir + .534*ig + .131*ib;
					og = .349*ir + .686*ig + .168*ib;
					ob = .393*ir + .969*ig + .589*ib;

					// adjust brightness towards the extremes
					or += ((or - 127) * 2);
					og += ((og - 127) * 2);
					ob += ((ob - 127) * 2);

					// wrap to 0->255
					or = Math.max(0, Math.min(or, 255));
					og = Math.max(0, Math.min(og, 255));
					ob = Math.max(0, Math.min(ob, 255));

					if (i % 40 == 0) {
						or *= .5;
						og *= .5;
						ob *= .5;
					}

					// or *= (i % width);
					// og *= (i % width);
					// ob *= (i % width);

					d[i] = or; d[i+1] = og; d[i+2] = ob;
				}

				return pixels;
			};

			CanvasFilter.filters.convoluteFloat32 = function(pixels, weights, opaque) {
				var side = Math.round(Math.sqrt(weights.length));
				var halfSide = Math.floor(side/2);

				var src = pixels.data;
				var sw = pixels.width;
				var sh = pixels.height;

				var w = sw;
				var h = sh;
				var output = {
					width: w, height: h, data: new Float32Array(w*h*4)
				};
				var dst = output.data;

				var alphaFac = opaque ? 1 : 0;

				for (var y=0; y<h; y++) {
					for (var x=0; x<w; x++) {
						var sy = y;
						var sx = x;
						var dstOff = (y*w+x)*4;
						var r=0, g=0, b=0, a=0;
						for (var cy=0; cy<side; cy++) {
							for (var cx=0; cx<side; cx++) {
								var scy = Math.min(sh-1, Math.max(0, sy + cy - halfSide));
								var scx = Math.min(sw-1, Math.max(0, sx + cx - halfSide));
								var srcOff = (scy*sw+scx)*4;
								var wt = weights[cy*side+cx];
								r += src[srcOff] * wt;
								g += src[srcOff+1] * wt;
								b += src[srcOff+2] * wt;
								a += src[srcOff+3] * wt;
							}
						}
						dst[dstOff] = r;
						dst[dstOff+1] = g;
						dst[dstOff+2] = b;
						dst[dstOff+3] = a + alphaFac*(255-a);
					}
				}
				return output;
			};

			CanvasFilter.filters.sobel = function(pixels, args) {
				pixels = CanvasFilter.filterPixels(pixels, CanvasFilter.filters.grayscale);

				var vertical = CanvasFilter.filters.convoluteFloat32(pixels,
				  [ -1, 0, 1,
				    -2, 0, 2,
				    -1, 0, 1 ]);
				var horizontal = CanvasFilter.filters.convoluteFloat32(pixels,
				  [ -1, -2, -1,
				     0,  0,  0,
				     1,  2,  1 ]);

				var newImage = CanvasFilter.createImageData(vertical.width, vertical.height);
				for (var i=0; i<pixels.data.length; i+=4) {
					// make the vertical gradient red
					var v = Math.abs(vertical.data[i]);
					newImage.data[i] = v;
					// make the horizontal gradient green
					var h = Math.abs(horizontal.data[i]);
					newImage.data[i+1] = h;
					// and mix in some blue for aesthetics
					newImage.data[i+2] = (v+h)/4;
					newImage.data[i+3] = 255; // opaque alpha
				}

				return newImage;
			};

			// @see https://github.com/benvanik/vr.js/blob/master/examples/threejs_boxes_demo.html
			// @see http://stemkoski.github.io/Three.js/Video.html
			(function() {
				var camera, scene, renderer,
					geometry, material, mesh,
					riftControls, riftEffect,
					vrState;

				var video, videoImage, videoImageContext, videoTexture,
					videoMaterial, videoGeometry, videoScreen;

				var fov = 90,
					videoWidth = 640,
					videoHeight = 480;

				if (!vr.isInstalled()) {
					alert('NPVR plugin not installed!');
				}

				vr.load(function(error) {
					if (error) {
						alert('NVPR plugin failed with error: ' + error.toString());
					}

					try {
						init();
						animate();
					} catch (e) {
						console.log(e);
					}
				});

				vrState = new vr.State();

				function init() {
					createRenderer();
					getWebcam();
				}

				function createRenderer() {
					// Create a camera
					camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 1, 1000);

					// Create a scene
					scene = new THREE.Scene();

					// Get the oculus rift controls and add them to the scene
					riftControls = new THREE.OculusRiftControls(camera);
					scene.add(riftControls.getObject());

					// Create renderer and apply oculus rift effect
					renderer = new THREE.WebGLRenderer({
						devicePixelRatio: 1,
						alpha: false,
						clearColor: 0xffffff,
						antialias: true
					});
					riftEffect = new THREE.OculusRiftEffect(renderer);

					// Add renderer to document
					document.body.appendChild(renderer.domElement);
				}

				function getWebcam() {
					navigator.webkitGetUserMedia({video: true, audio: false}, function(stream) {
						// Create the video element and grab the src from the webcam stream
						video = document.createElement('video');
						video.src = window.URL.createObjectURL(stream);
						video.play();

						// Create a canvas for the video
						videoImage = document.createElement('canvas');
						videoImage.width = videoWidth;
						videoImage.height = videoHeight;

						// Blank out the canvas if there is no video
						videoImageContext = videoImage.getContext('2d');
						videoImageContext.fillStyle = '#000000';
						videoImageContext.fillRect(0, 0, videoImage.width, videoImage.height);

						// Create a texture from the video image
						videoTexture = new THREE.Texture(videoImage);
						videoTexture.minFilter = THREE.LinearFilter;
						videoTexture.magFilter = THREE.LinearFilter;

						// Create a material and geometry and apply them to a mesh
						videoMaterial = new THREE.MeshBasicMaterial({
							map: videoTexture,
							overdraw: true
						})
						videoGeometry = new THREE.PlaneGeometry(240, videoHeight * (240 / videoWidth), 4, 4);
						videoScreen = new THREE.Mesh(videoGeometry, videoMaterial);
						videoScreen.position.set(0, 0, 0);

						// Add the video screen mesh to the scene and point the camera at it
						scene.add(videoScreen);

						camera.position.set(0, 0, 100);
						camera.lookAt(videoScreen.position);
					});
				}

				function animate() {
					requestAnimationFrame(animate);
					render();
					update();
				}

				function update() {
					// boo
				}

				function render()  {
					if (video && video.readyState === video.HAVE_ENOUGH_DATA) {
						videoImageContext.drawImage(video, 0, 0);

						// Apply filter
						var data = CanvasFilter.applyFilter(videoImage, videoImageContext, CanvasFilter.filters.spycam, videoImage.width, videoImage.height);
						videoImageContext.putImageData(data, 0, 0);

						if (videoTexture) {
							videoTexture.needsUpdate = true;
						}
					}

					var polled = vr.pollState(vrState);
					riftEffect.render(scene, camera, polled ? vrState : null);
				}
			})();
		</script>
	</body>
</head>